/**
 * Data API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 20.8
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 */

import ApiClient from "../ApiClient";
import ContentAsset from '../models/ContentAsset';
import ContentAssetResult from '../models/ContentAssetResult';
import ContentFolder from '../models/ContentFolder';
import ContentFolderAssignment from '../models/ContentFolderAssignment';
import ContentFolderResult from '../models/ContentFolderResult';
import ContentSubFolderResult from '../models/ContentSubFolderResult';

/**
* Libraries service.
* @module api/LibrariesApi
* @version 20.8
*/
export default class LibrariesApi {

    /**
    * Constructs a new LibrariesApi. 
    * @alias module:api/LibrariesApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }



    /**
     * Deletes the content asset with the specified ID from the specified library. If the content asset is not found, the server returns a 404 (NotFoundException) fault. If the content asset is locked by another user, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteLibrariesByIDContentByIDWithHttpInfo(libraryId, contentId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;

      return this.apiClient.callApi(
        '/libraries/{library_id}/content/{content_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Deletes the content asset with the specified ID from the specified library. If the content asset is not found, the server returns a 404 (NotFoundException) fault. If the content asset is locked by another user, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteLibrariesByIDContentByID(libraryId, contentId) {
      return this.deleteLibrariesByIDContentByIDWithHttpInfo(libraryId, contentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to unassign a content asset from the specified library folder.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to unassign a content asset from the specified library folder.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteLibrariesByIDFolderAssignmentsByIDByID(libraryId, contentId, folderId) {
      return this.deleteLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Delete folder
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing HTTP response
     */
    deleteLibrariesByIDFoldersByIDWithHttpInfo(libraryId, folderId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = [];
      let returnType = null;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}', 'DELETE',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Delete folder
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}
     */
    deleteLibrariesByIDFoldersByID(libraryId, folderId) {
      return this.deleteLibrariesByIDFoldersByIDWithHttpInfo(libraryId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Returns a content asset using the specified ID. If the content asset cannot be found, the server returns a 404 (ContentNotFoundException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException).
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentAsset} and HTTP response
     */
    getLibrariesByIDContentByIDWithHttpInfo(libraryId, contentId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentAsset;

      return this.apiClient.callApi(
        '/libraries/{library_id}/content/{content_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Returns a content asset using the specified ID. If the content asset cannot be found, the server returns a 404 (ContentNotFoundException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException).
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentAsset}
     */
    getLibrariesByIDContentByID(libraryId, contentId) {
      return this.getLibrariesByIDContentByIDWithHttpInfo(libraryId, contentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to get all assigned folders of a content asset.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolderResult} and HTTP response
     */
    getLibrariesByIDContentByIDFoldersWithHttpInfo(libraryId, contentId, opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId
      };
      let queryParams = {
        'start': opts['start'],
        'count': opts['count']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolderResult;

      return this.apiClient.callApi(
        '/libraries/{library_id}/content/{content_id}/folders', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to get all assigned folders of a content asset.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolderResult}
     */
    getLibrariesByIDContentByIDFolders(libraryId, contentId, opts) {
      return this.getLibrariesByIDContentByIDFoldersWithHttpInfo(libraryId, contentId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to get a single content to folder assignment
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolderAssignment} and HTTP response
     */
    getLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolderAssignment;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to get a single content to folder assignment
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolderAssignment}
     */
    getLibrariesByIDFolderAssignmentsByIDByID(libraryId, contentId, folderId) {
      return this.getLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to get folder information.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolder} and HTTP response
     */
    getLibrariesByIDFoldersByIDWithHttpInfo(libraryId, folderId) {
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolder;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to get folder information.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolder}
     */
    getLibrariesByIDFoldersByID(libraryId, folderId) {
      return this.getLibrariesByIDFoldersByIDWithHttpInfo(libraryId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to get all assigned content assets of a folder.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentAssetResult} and HTTP response
     */
    getLibrariesByIDFoldersByIDContentWithHttpInfo(libraryId, folderId, opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
        'start': opts['start'],
        'count': opts['count']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentAssetResult;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}/content', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to get all assigned content assets of a folder.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentAssetResult}
     */
    getLibrariesByIDFoldersByIDContent(libraryId, folderId, opts) {
      return this.getLibrariesByIDFoldersByIDContentWithHttpInfo(libraryId, folderId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to get sub folders information.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentSubFolderResult} and HTTP response
     */
    getLibrariesByIDFoldersByIDSubFoldersWithHttpInfo(libraryId, folderId, opts) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
        'start': opts['start'],
        'count': opts['count']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = [];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentSubFolderResult;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}/sub_folders', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to get sub folders information.
     * @param {Object} opts Optional parameters
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentSubFolderResult}
     */
    getLibrariesByIDFoldersByIDSubFolders(libraryId, folderId, opts) {
      return this.getLibrariesByIDFoldersByIDSubFoldersWithHttpInfo(libraryId, folderId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updates a content asset. In the request, the If-Match header is required. The value of the header is an &#x27;ETag&#x27; representing the last known base-point information for the content asset. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server&#x27;s &#x27;ETag&#x27;, the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder containing the content asset is updated atomically: the information is written completely or not at all. If the content asset is locked, the server returns a 409 (ResourceLockedException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentAsset} and HTTP response
     */
    patchLibrariesByIDContentByIDWithHttpInfo(body, libraryId, contentId) {
      let postBody = body;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentAsset;

      return this.apiClient.callApi(
        '/libraries/{library_id}/content/{content_id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Updates a content asset. In the request, the If-Match header is required. The value of the header is an &#x27;ETag&#x27; representing the last known base-point information for the content asset. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server&#x27;s &#x27;ETag&#x27;, the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder containing the content asset is updated atomically: the information is written completely or not at all. If the content asset is locked, the server returns a 409 (ResourceLockedException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentAsset}
     */
    patchLibrariesByIDContentByID(body, libraryId, contentId) {
      return this.patchLibrariesByIDContentByIDWithHttpInfo(body, libraryId, contentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to update a single content to folder assignment. Currently only the position and default attribute can be changed.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolderAssignment} and HTTP response
     */
    patchLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(body, libraryId, contentId, folderId) {
      let postBody = body;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolderAssignment;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to update a single content to folder assignment. Currently only the position and default attribute can be changed.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolderAssignment}
     */
    patchLibrariesByIDFolderAssignmentsByIDByID(body, libraryId, contentId, folderId) {
      return this.patchLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(body, libraryId, contentId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Updates an existing folder. In the request, the If-Match header is required. The value of the header is an &#x27;ETag&#x27; representing the last known base-point information for the library folder. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server&#x27;s &#x27;ETag&#x27;, the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder is updated atomically: the information is written completely or not at all.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolder} and HTTP response
     */
    patchLibrariesByIDFoldersByIDWithHttpInfo(body, libraryId, folderId) {
      let postBody = body;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolder;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}', 'PATCH',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Updates an existing folder. In the request, the If-Match header is required. The value of the header is an &#x27;ETag&#x27; representing the last known base-point information for the library folder. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server&#x27;s &#x27;ETag&#x27;, the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder is updated atomically: the information is written completely or not at all.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolder}
     */
    patchLibrariesByIDFoldersByID(body, libraryId, folderId) {
      return this.patchLibrariesByIDFoldersByIDWithHttpInfo(body, libraryId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Creates a new content asset in the specified library, or overwrites an existing content asset. If a content asset with the specified ID already exists, the server completely overwrites the content asset. Please note: Existing folder assignments are not touched. If the existing content asset is locked, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentAsset} and HTTP response
     */
    putLibrariesByIDContentByIDWithHttpInfo(body, libraryId, contentId) {
      let postBody = body;

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentAsset;

      return this.apiClient.callApi(
        '/libraries/{library_id}/content/{content_id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Creates a new content asset in the specified library, or overwrites an existing content asset. If a content asset with the specified ID already exists, the server completely overwrites the content asset. Please note: Existing folder assignments are not touched. If the existing content asset is locked, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentAsset}
     */
    putLibrariesByIDContentByID(body, libraryId, contentId) {
      return this.putLibrariesByIDContentByIDWithHttpInfo(body, libraryId, contentId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to assign a content asset to a specified folder.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolderAssignment} and HTTP response
     */
    putLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId, opts) {
      let postBody = opts['body'];

      let pathParams = {
        'library_id': libraryId,
        'content_id': contentId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolderAssignment;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to assign a content asset to a specified folder.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolderAssignment}
     */
    putLibrariesByIDFolderAssignmentsByIDByID(libraryId, contentId, folderId, opts) {
      return this.putLibrariesByIDFolderAssignmentsByIDByIDWithHttpInfo(libraryId, contentId, folderId, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Action to create a new library folder, or to replace an existing folder. This action completely overwrites existing folders. Please note: Sub folders and assignments to content assets are not touched. This action ignores the folder ID in the input document.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:models/ContentFolder} and HTTP response
     */
    putLibrariesByIDFoldersByIDWithHttpInfo(body, libraryId, folderId) {
      let postBody = body;

      let pathParams = {
        'library_id': libraryId,
        'folder_id': folderId
      };
      let queryParams = {
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = ['oauth2_application'];
      let contentTypes = ['application/json', 'text/xml', 'application/xml'];
      let accepts = ['application/json', 'text/xml', 'application/xml'];
      let returnType = ContentFolder;

      return this.apiClient.callApi(
        '/libraries/{library_id}/folders/{folder_id}', 'PUT',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType
      );
    }

    /**
     * Action to create a new library folder, or to replace an existing folder. This action completely overwrites existing folders. Please note: Sub folders and assignments to content assets are not touched. This action ignores the folder ID in the input document.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:models/ContentFolder}
     */
    putLibrariesByIDFoldersByID(body, libraryId, folderId) {
      return this.putLibrariesByIDFoldersByIDWithHttpInfo(body, libraryId, folderId)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }

}
